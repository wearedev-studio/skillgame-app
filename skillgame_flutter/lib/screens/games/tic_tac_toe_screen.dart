import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:skillgame_flutter/providers/game_provider.dart';
import 'package:skillgame_flutter/providers/auth_provider.dart';
import 'package:skillgame_flutter/models/game_model.dart';
import 'package:skillgame_flutter/services/notification_service.dart';
import 'package:skillgame_flutter/utils/theme.dart';
import 'package:skillgame_flutter/widgets/custom_button.dart';
import 'game_lobby_screen.dart';

class TicTacToeScreen extends StatefulWidget {
  const TicTacToeScreen({super.key});

  @override
  State<TicTacToeScreen> createState() => _TicTacToeScreenState();
}

class _TicTacToeScreenState extends State<TicTacToeScreen> {
  List<String> board = List.filled(9, '');
  String currentPlayer = 'X';
  String gameStatus = 'Connecting...';
  bool gameEnded = false;
  String? winner;
  bool isMyTurn = false;
  String? mySymbol;
  String? roomId;
  String? _errorMessage;
  GameProvider? _gameProvider;
  bool _isSearchingForOpponent = false;
  int _searchTimeoutSeconds = 0;
  bool _canCancelSearch =
      false; // –ú–æ–∂–Ω–æ –ª–∏ –æ—Ç–º–µ–Ω–∏—Ç—å –ø–æ–∏—Å–∫ (true –µ—Å–ª–∏ —Å–æ–∑–¥–∞–ª –∫–æ–º–Ω–∞—Ç—É —Å–∞–º)

  // Move timer variables
  int _moveTimeRemaining = 0;
  Timer? _moveTimer;
  bool _showMoveTimer = false;
  String? _currentTurnPlayerId;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initGame();
    });
  }

  void _initGame() {
    _gameProvider = Provider.of<GameProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    if (authProvider.isAuthenticated) {
      // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ WebSocket –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Å–ª—É—à–∞—Ç–µ–ª–∏
      _gameProvider!.connectToWebSocket(authProvider.token!);
      _setupGameListeners(_gameProvider!);

      // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞ –ø–µ—Ä–µ–¥ –ø–æ–∏—Å–∫–æ–º
      final currentRoom = _gameProvider!.currentRoom;
      if (!gameEnded &&
          currentRoom != null &&
          currentRoom.players.length >= 2) {
        // –£–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞ —Å –∏–≥—Ä–æ–∫–∞–º–∏ - –ù–ï –∑–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫
        print(
            'üéÆ INIT: Found existing room ${currentRoom.id} with ${currentRoom.players.length} players');
        setState(() {
          roomId = currentRoom.id;
          gameStatus = 'Joining existing game...';
          _isSearchingForOpponent = false;
          _canCancelSearch = false;
        });

        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∏–≥—Ä—É —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∫–æ–º–Ω–∞—Ç–æ–π
        _setupExistingRoom(currentRoom);
      } else if (!gameEnded &&
          currentRoom != null &&
          currentRoom.players.length == 1) {
        // –ï—Å—Ç—å –∫–æ–º–Ω–∞—Ç–∞ –Ω–æ —Ç–æ–ª—å–∫–æ 1 –∏–≥—Ä–æ–∫ - –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–∂–∏–¥–∞–Ω–∏–µ
        print(
            'üéÆ INIT: Found existing room ${currentRoom.id} with 1 player - waiting for more');
        setState(() {
          roomId = currentRoom.id;
          gameStatus = 'Waiting for second player...';
          _isSearchingForOpponent = true;
          _canCancelSearch = true;
        });
      } else if (!gameEnded) {
        // –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –∫–æ–º–Ω–∞—Ç—ã - –Ω–∞—á–∏–Ω–∞–µ–º –ø–æ–∏—Å–∫
        print('üéÆ INIT: No active room - starting search');
        setState(() {
          gameStatus = 'Looking for opponent...';
          _isSearchingForOpponent = true;
          _canCancelSearch = true;
        });

        // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º—Å—è –∫ –ª–æ–±–±–∏ –∏ –∏—â–µ–º –∏–≥—Ä—É
        _gameProvider!.joinLobby('tic-tac-toe');
        _joinLobbyAndSearch(_gameProvider!);
      } else {
        setState(() {
          gameStatus = 'Game completed';
          _isSearchingForOpponent = false;
        });
      }

      // Show error if not connected after timeout
      Future.delayed(const Duration(seconds: 5), () {
        if (!_gameProvider!.isConnected && !gameEnded) {
          setState(() {
            _errorMessage =
                'Unable to connect to game server. Please check your internet connection.';
            gameStatus = 'Connection failed';
          });
        }
      });
    } else {
      setState(() {
        _errorMessage = 'Please log in to play games';
        gameStatus = 'Not authenticated';
      });
    }
  }

  void _setupExistingRoom(Room room) {
    print('üéÆ SETUP: Setting up existing room ${room.id}');

    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final myUserId = authProvider.user?.id;

    setState(() {
      roomId = room.id;
      board = List.filled(9, '');
      gameEnded = false;
      _errorMessage = null;

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–∏–º–≤–æ–ª –∏–≥—Ä–æ–∫–∞ –∏ —á–µ–π —Ö–æ–¥
      if (room.players.length >= 2) {
        // –ù–∞–π—Ç–∏ –º–æ–π –∏–Ω–¥–µ–∫—Å —Å—Ä–µ–¥–∏ –∏–≥—Ä–æ–∫–æ–≤
        int myIndex = -1;
        for (int i = 0; i < room.players.length; i++) {
          if (room.players[i].user.id == myUserId) {
            myIndex = i;
            break;
          }
        }

        if (myIndex >= 0) {
          mySymbol = myIndex == 0 ? 'X' : 'O';
          print('üéÆ SETUP: My symbol = $mySymbol (index $myIndex)');

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
          if (room.gameState != null) {
            final gameData = room.gameState!.data;

            // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–æ—Å–∫—É
            if (gameData['board'] != null) {
              final serverBoard = gameData['board'] as List<dynamic>;
              board =
                  serverBoard.map((cell) => cell?.toString() ?? '').toList();
              print('üéÆ SETUP: Loaded board = $board');
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–µ–π —Ö–æ–¥
            final currentTurnPlayerId = gameData['turn'];
            isMyTurn = currentTurnPlayerId == myUserId;
            gameStatus = isMyTurn ? 'Your turn' : 'Opponent\'s turn';

            print(
                'üéÆ SETUP: Current turn = $currentTurnPlayerId, my turn = $isMyTurn');
          } else {
            // –ù–æ–≤–∞—è –∏–≥—Ä–∞
            isMyTurn = mySymbol == 'X'; // X —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º
            gameStatus = isMyTurn ? 'Your turn' : 'Opponent\'s turn';
          }
        }
      } else {
        // –¢–æ–ª—å–∫–æ –æ–¥–∏–Ω –∏–≥—Ä–æ–∫ - –∂–¥–µ–º –≤—Ç–æ—Ä–æ–≥–æ
        mySymbol = 'X';
        isMyTurn = false;
        gameStatus = 'Waiting for second player...';
      }
    });
  }

  void _createBotRoom() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    setState(() {
      gameStatus = 'Creating game with bot...';
      board = List.filled(9, '');
      gameEnded = false;
      winner = null;
      isMyTurn = false;
      mySymbol = null;
      roomId = null;
    });

    // Create room, server will add bot automatically if no human player joins
    gameProvider.createRoom('tic-tac-toe', 0.0);
  }

  void _setupGameListeners(GameProvider gameProvider) {
    // Listen for game start - –ù–ï –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º callback GameProvider!
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π callback GameProvider
    final originalOnGameStart = gameProvider.webSocketService.onGameStart;

    gameProvider.webSocketService.onGameStart = (room) {
      print('=== TIC TAC TOE GAME START CALLBACK ===');
      print('Room ID: ${room.id}');
      print('Mounted: $mounted');

      // –°–Ω–∞—á–∞–ª–∞ –≤—ã–∑—ã–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π callback GameProvider
      originalOnGameStart?.call(room);

      // –ü–æ—Ç–æ–º –Ω–∞—à –ª–æ–∫–∞–ª—å–Ω—ã–π callback
      if (mounted) {
        print('=== UPDATING TIC TAC TOE STATE ===');
        setState(() {
          roomId = room.id; // –ö–†–ò–¢–ò–ß–ù–û: —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º roomId
          board = List.filled(9, '');
          gameEnded = false;
          _errorMessage = null; // –ò–°–ü–†–ê–í–õ–ï–ù–û: –û—á–∏—â–∞–µ–º –æ—à–∏–±–∫–∏ –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –∏–≥—Ä—ã

          // –ò–°–ü–†–ê–í–õ–ï–ù–û: –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∏—Å–∫ –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –µ—Å—Ç—å 2+ –∏–≥—Ä–æ–∫–æ–≤
          if (room.players.length >= 2) {
            _isSearchingForOpponent = false;
            _searchTimeoutSeconds = 0;
            print('STOPPING SEARCH - 2+ players found');
          } else {
            print(
                'KEEPING SEARCH - only ${room.players.length} player(s), waiting for more');
          }

          // Determine player symbol based on position in room
          final players = room.players;
          print('Players count: ${players.length}');
          if (players.isNotEmpty) {
            final authProvider =
                Provider.of<AuthProvider>(context, listen: false);
            final myUserId = authProvider.user?.id;
            print('My user ID: $myUserId');

            // –ò–°–ü–†–ê–í–õ–ï–ù–û: –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–∏–º–≤–æ–ª–∞
            if (players.length >= 2) {
              // –ù–∞–π—Ç–∏ –º–æ–π –∏–Ω–¥–µ–∫—Å —Å—Ä–µ–¥–∏ –∏–≥—Ä–æ–∫–æ–≤
              int myIndex = -1;
              for (int i = 0; i < players.length; i++) {
                if (players[i].user.id == myUserId) {
                  myIndex = i;
                  break;
                }
              }

              if (myIndex >= 0) {
                mySymbol = myIndex == 0 ? 'X' : 'O';
                isMyTurn = mySymbol == 'X'; // X goes first
                currentPlayer = 'X';
                print('My player index: $myIndex');
                print('My symbol: $mySymbol');
                print('Is my turn: $isMyTurn');

                // –í–ê–ñ–ù–û: –ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å —Å –¥–≤—É–º—è –∏–≥—Ä–æ–∫–∞–º–∏
                gameStatus = isMyTurn ? 'Your turn' : 'Opponent\'s turn';
                print('GAME STARTED WITH 2 PLAYERS');
              } else {
                // Fallback –µ—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –∏–≥—Ä–æ–∫–∞
                mySymbol = 'X';
                isMyTurn = true;
                gameStatus = 'Your turn';
                print('Fallback: set as X');
              }
            } else if (players.length == 1) {
              // –¢–æ–ª—å–∫–æ –æ–¥–∏–Ω –∏–≥—Ä–æ–∫ - –∂–¥–µ–º –≤—Ç–æ—Ä–æ–≥–æ (—ç—Ç–æ –ù–ï –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å –≤ gameStart)
              mySymbol = 'X';
              isMyTurn = false; // –ù–ï –º–æ–∂–µ–º —Ö–æ–¥–∏—Ç—å –ø–æ–∫–∞ –Ω–µ—Ç –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞
              gameStatus = 'Waiting for second player...';
              print('WARNING: gameStart called with only 1 player');
            }
          }
        });

        print('=== TIC TAC TOE STATE UPDATED ===');
        print('Final roomId: $roomId');
        print('Final isMyTurn: $isMyTurn');
        print('Final mySymbol: $mySymbol');
        print('Final gameStatus: $gameStatus');
        print('Final _isSearchingForOpponent: $_isSearchingForOpponent');
      } else {
        print('=== TIC TAC TOE NOT MOUNTED ===');
      }
    };

    // Listen for move timer events with room ID filtering
    gameProvider.webSocketService.onMoveTimerStart = (data) {
      if (mounted && roomId != null) {
        final timeLimit = data['timeLimit'] as int;
        final currentPlayerId = data['currentPlayerId'] as String;
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final isMyTurn = currentPlayerId == authProvider.user?.id;

        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–≤–æ–µ–π –∫–æ–º–Ω–∞—Ç—ã
        print('‚è∞ TIMER START for $currentPlayerId in current room: $roomId');

        setState(() {
          _moveTimeRemaining = (timeLimit / 1000).round();
          _currentTurnPlayerId = currentPlayerId;
          _showMoveTimer = isMyTurn; // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–≤–æ–µ–≥–æ —Ö–æ–¥–∞
        });

        _startMoveTimer();
      }
    };

    gameProvider.webSocketService.onMoveTimerWarning = (data) {
      if (mounted && roomId != null) {
        final timeRemaining = data['timeRemaining'] as int;
        final currentPlayerId = data['currentPlayerId'] as String;
        final authProvider = Provider.of<AuthProvider>(context, listen: false);

        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –Ω–∞—à —Ö–æ–¥
        if (currentPlayerId == authProvider.user?.id) {
          setState(() {
            _moveTimeRemaining = (timeRemaining / 1000).round();
          });
          print(
              '‚ö†Ô∏è TIMER WARNING: ${_moveTimeRemaining}s remaining for my turn');
        }
      }
    };

    // Listen for game updates - —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π –ø–æ roomId
    gameProvider.webSocketService.onGameUpdate = (room) {
      print('=== GAME UPDATE CALLBACK ===');
      print('Room ID from update: ${room.id}');
      print('Local roomId before: $roomId');
      print('Local mySymbol before: $mySymbol');
      print('Players in room: ${room.players.length}');
      print('_isSearchingForOpponent before: $_isSearchingForOpponent');

      // –ò–°–ü–†–ê–í–õ–ï–ù–û: –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–ª—è –°–í–û–ï–ô –∫–æ–º–Ω–∞—Ç—ã
      if (roomId != null && roomId != room.id) {
        print(
            '‚ö†Ô∏è TIC TAC TOE: Ignoring gameUpdate for foreign room ${room.id} (my room: $roomId)');
        return;
      }

      if (room.gameState != null) {
        print('üéÆ GAME UPDATE: Processing gameState for room ${room.id}');
        print('üéÆ GAME UPDATE: gameState.data = ${room.gameState!.data}');

        setState(() {
          // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∏—Å–∫ –µ—Å–ª–∏ –µ—â–µ –∞–∫—Ç–∏–≤–µ–Ω
          if (_isSearchingForOpponent) {
            print('üîç GAME UPDATE: Stopping search during gameUpdate');
            _isSearchingForOpponent = false;
          }

          // Update board from server
          final gameData = room.gameState!.data;
          print('üéØ BOARD UPDATE: gameData = $gameData');

          if (gameData['board'] != null) {
            final serverBoard = gameData['board'] as List<dynamic>;
            final newBoard =
                serverBoard.map((cell) => cell?.toString() ?? '').toList();
            print('üéØ BOARD UPDATE: Old board = $board');
            print('üéØ BOARD UPDATE: New board = $newBoard');
            board = newBoard;
          } else {
            print('‚ö†Ô∏è BOARD UPDATE: No board data in gameState');
          }

          // Update turn - server sends player ID, need to check if it's my turn
          final currentTurnPlayerId = gameData['turn'];
          final authProvider =
              Provider.of<AuthProvider>(context, listen: false);
          final myUserId = authProvider.user?.id;
          isMyTurn = currentTurnPlayerId == myUserId;

          if (room.gameState!.isGameFinished) {
            // –ö–†–ò–¢–ò–ß–ù–û: –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–∞–π–º–µ—Ä –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∏–≥—Ä—ã
            _stopMoveTimer();
            setState(() {
              _showMoveTimer = false;
            });

            gameEnded = true;
            final winnerData = gameData['winner'];

            // Determine winner based on response format
            if (winnerData != null) {
              if (winnerData == myUserId) {
                winner = mySymbol;
                gameStatus = 'You win!';
              } else {
                winner = mySymbol == 'X' ? 'O' : 'X';
                gameStatus = 'Opponent wins!';
              }
            } else {
              winner = null;
              gameStatus = 'Draw!';
            }

            // Show game end notification if roomId is available
            if (roomId != null) {
              NotificationService.showGameEnd(
                gameType: 'Tic Tac Toe',
                result: gameStatus,
                roomId: roomId!,
              );
            }
          } else {
            gameStatus = isMyTurn ? 'Your turn' : 'Opponent\'s turn';

            // Show your turn notification if roomId is available
            if (isMyTurn && roomId != null) {
              NotificationService.showYourTurn(
                gameType: 'Tic Tac Toe',
                roomId: roomId!,
              );
            }
          }
        });
      }

      print('Local roomId after: $roomId');
      print('Local mySymbol after: $mySymbol');
      print('=== END GAME UPDATE ===');
    };

    // Listen for game end with room filtering
    gameProvider.webSocketService.onGameEnd = (result) {
      // –ò–°–ü–†–ê–í–õ–ï–ù–û: –§–∏–ª—å—Ç—Ä—É–µ–º gameEnd –ø–æ roomId
      if (gameEnded) {
        print('üéÆ GAME END: Already processed - ignoring');
        return;
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –Ω–∞—à–µ–π –∏–≥—Ä—ã
      if (roomId == null) {
        print('üéÆ GAME END: No roomId - ignoring');
        return;
      }

      setState(() {
        // –ö–†–ò–¢–ò–ß–ù–û: –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–µ—Å—å –ø–æ–∏—Å–∫ –∏ —Ç–∞–π–º–µ—Ä –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∏–≥—Ä—ã
        print('=== GAME ENDED - STOPPING ALL ACTIVITY ===');
        _isSearchingForOpponent = false;
        _searchTimeoutSeconds = 0;
        _canCancelSearch = false;
        _stopMoveTimer();
        _showMoveTimer = false;

        // –í–ê–ñ–ù–û: –ü–æ–ø—ã—Ç–∞—Ç—å—Å—è –ø–æ–ª—É—á–∏—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–æ—Å–∫–∏ –∏–∑ gameProvider
        final gameProvider = Provider.of<GameProvider>(context, listen: false);
        final currentRoom = gameProvider.currentRoom;
        if (currentRoom?.gameState?.data != null) {
          final gameData = currentRoom!.gameState!.data;
          if (gameData['board'] != null) {
            final serverBoard = gameData['board'] as List<dynamic>;
            board = serverBoard.map((cell) => cell?.toString() ?? '').toList();
            print('=== UPDATED BOARD FROM FINAL GAME STATE ===');
            print('Final board: $board');
          }
        }

        gameEnded = true;

        // Parse winner correctly - server can send different formats
        final winnerData = result['winner'];
        if (winnerData != null) {
          if (winnerData is String) {
            winner = winnerData;
          } else if (winnerData is Map) {
            // If winner is a player object, extract username or check if it's me
            final authProvider =
                Provider.of<AuthProvider>(context, listen: false);
            final winnerId = winnerData['user']?['_id'] ?? winnerData['_id'];
            if (winnerId == authProvider.user?.id) {
              winner = mySymbol;
              gameStatus = 'You win!';
            } else {
              winner = mySymbol == 'X' ? 'O' : 'X';
              gameStatus = 'You lose!';
            }
          }
        } else {
          winner = null;
          gameStatus = 'Draw!';
        }

        // Use provided message if no custom status set
        if (result['message'] != null && !gameStatus.contains('You')) {
          gameStatus = result['message'];
        }

        print('Game ended. Final status: $gameStatus');
      });

      // Show notification
      NotificationService.showGameEnd(
        gameType: 'Tic Tac Toe',
        result: gameStatus,
        roomId: roomId ?? 'unknown',
      );
    };

    // Listen for opponent disconnected
    gameProvider.webSocketService.onOpponentDisconnected = (message) {
      if (roomId != null) {
        NotificationService.showOpponentDisconnected(
          gameType: 'Tic Tac Toe',
          roomId: roomId!,
        );
      }
    };

    // Listen for errors
    gameProvider.webSocketService.onError = (error) {
      if (mounted) {
        setState(() {
          _errorMessage = error;
        });
      }
    };

    // Listen for game timeout using WebSocketService callback
    gameProvider.webSocketService.onGameTimeout = (data) {
      if (mounted && !gameEnded) {
        // –ù–ï –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å timeout –µ—Å–ª–∏ –∏–≥—Ä–∞ —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
        _stopMoveTimer();
        setState(() {
          _showMoveTimer = false;
        });
        print('Game timeout received');
      } else {
        print('Game timeout ignored - game already ended');
      }
    };
  }

  void _startMoveTimer() {
    _moveTimer?.cancel();
    _moveTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!mounted) {
        timer.cancel();
        return;
      }

      // –ö–†–ò–¢–ò–ß–ù–û: –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–∞–π–º–µ—Ä –µ—Å–ª–∏ –∏–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
      if (gameEnded) {
        timer.cancel();
        setState(() {
          _showMoveTimer = false;
        });
        return;
      }

      setState(() {
        _moveTimeRemaining--;
      });

      if (_moveTimeRemaining <= 0) {
        timer.cancel();
        setState(() {
          _showMoveTimer = false;
        });
      }
    });
  }

  void _stopMoveTimer() {
    _moveTimer?.cancel();
    _moveTimer = null;
  }

  void _makeMove(int index) {
    print(
        'üéØ MOVE: Cell $index in room $roomId (turn: $isMyTurn, symbol: $mySymbol)');

    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ —Ö–æ–¥–∞
    if (board[index] != '' || gameEnded || !isMyTurn || roomId == null) {
      if (board[index] != '') print('üö´ MOVE: Cell not empty');
      if (gameEnded) print('üö´ MOVE: Game ended');
      if (!isMyTurn) print('üö´ MOVE: Not my turn');
      if (roomId == null) print('üö´ MOVE: No room ID');
      return;
    }

    // Send move to server via WebSocket
    if (gameProvider.isConnected && roomId != null) {
      print('‚úÖ MOVE: Sending cell $index to server');

      gameProvider.makeMove(GameMove(
        type: 'cellMove', // –¢–æ–ª—å–∫–æ –¥–ª—è –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–π –ª–æ–≥–∏–∫–∏
        data: {
          'cellIndex': index,
        },
      ));

      setState(() {
        gameStatus = 'Move sent, waiting for response...';
      });
    } else {
      print(
          '‚ùå MOVE: Not connected (connected: ${gameProvider.isConnected}, roomId: $roomId)');
      setState(() {
        _errorMessage = 'Not connected to game server';
      });
    }
  }

  // Removed offline game logic - all game logic handled by server

  void _resetGame() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    if (authProvider.isAuthenticated) {
      // Leave current room if any
      if (roomId != null) {
        gameProvider.leaveRoom();
      }

      // Reset local state
      setState(() {
        board = List.filled(9, '');
        currentPlayer = 'X';
        gameStatus = 'Looking for opponent...';
        gameEnded = false;
        winner = null;
        isMyTurn = false;
        mySymbol = null;
        roomId = null;
      });

      // Join lobby again to find new opponent
      gameProvider.joinLobby('tic-tac-toe');
    }
  }

  void _createRoom() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    gameProvider.createRoom('tic-tac-toe', 0.0); // No bet for demo
    setState(() {
      gameStatus = 'Creating room...';
    });
  }

  void _findOpponent() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    if (!authProvider.isAuthenticated) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please log in to find opponents'),
          backgroundColor: AppTheme.errorColor,
        ),
      );
      return;
    }

    // Start searching animation - –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –ø–æ–∏—Å–∫–∞
    setState(() {
      _isSearchingForOpponent = true; // –ö–†–ò–¢–ò–ß–ù–û: —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –ø–æ–∏—Å–∫–∞
      _searchTimeoutSeconds = 0;
      board = List.filled(9, '');
      currentPlayer = 'X';
      gameStatus = 'Connecting to server...';
      gameEnded = false;
      winner = null;
      isMyTurn = false;
      mySymbol = null;
      roomId = null; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º roomId
      _errorMessage = null;
    });

    // Connect to WebSocket if not connected
    if (!gameProvider.isConnected) {
      setState(() {
        gameStatus = 'Connecting to game server...';
      });

      gameProvider.connectToWebSocket(authProvider.token!);
      _setupGameListeners(gameProvider);

      // Wait for connection before joining lobby
      Future.delayed(const Duration(seconds: 2), () {
        if (mounted && gameProvider.isConnected) {
          _joinLobbyAndSearch(gameProvider);
        } else if (mounted) {
          setState(() {
            gameStatus = 'Connection failed';
            _isSearchingForOpponent = false;
            _errorMessage =
                'Unable to connect to game server. Please check your internet connection and try again.';
          });
        }
      });
    } else {
      _joinLobbyAndSearch(gameProvider);
    }
  }

  void _joinLobbyAndSearch(GameProvider gameProvider) async {
    print('=== JOINING LOBBY AND SEARCH ===');
    print('_canCancelSearch before: $_canCancelSearch');

    // Leave current room if any
    if (roomId != null) {
      gameProvider.leaveRoom();
    }

    setState(() {
      gameStatus = 'Searching for opponents...';
    });

    gameProvider.joinLobby('tic-tac-toe');

    // Try to find and join an existing room first
    bool joinedExistingRoom =
        await gameProvider.findAndJoinAvailableRoom('tic-tac-toe');

    if (joinedExistingRoom) {
      print('Successfully found/joined room');
      setState(() {
        gameStatus = 'Found game, waiting for start...';
        _canCancelSearch = false; // –ù–µ –º–æ–∂–µ–º –æ—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞
        // –ü–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –≤ gameStart callback
      });
      return;
    }

    print('No room found - starting search countdown');
    setState(() {
      _canCancelSearch = true; // –ú–æ–∂–µ–º –æ—Ç–º–µ–Ω–∏—Ç—å –≤–æ –≤—Ä–µ–º—è –ø–æ–∏—Å–∫–∞
    });

    _startSearchCountdown();

    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Searching for opponent online...'),
        backgroundColor: AppTheme.primaryColor,
        duration: Duration(seconds: 2),
      ),
    );

    print('_canCancelSearch after: $_canCancelSearch');
    print('=== END JOINING LOBBY AND SEARCH ===');
  }

  void _startSearchCountdown() {
    Future.delayed(const Duration(seconds: 1), () {
      if (mounted && _isSearchingForOpponent) {
        setState(() {
          _searchTimeoutSeconds++;
          if (_searchTimeoutSeconds <= 15) {
            gameStatus =
                'Searching for opponents... (${16 - _searchTimeoutSeconds}s)';
          }
        });

        if (_searchTimeoutSeconds < 15) {
          _startSearchCountdown();
        } else {
          // Timeout - show options
          _showOpponentNotFoundDialog();
        }
      }
    });
  }

  void _showOpponentNotFoundDialog() {
    setState(() {
      _isSearchingForOpponent = false;
      gameStatus = 'No opponents found';
    });

    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          backgroundColor: AppTheme.surfaceColor,
          title: Text(
            'No Opponents Online',
            style: TextStyle(color: AppTheme.textPrimary),
          ),
          content: Text(
            'Currently there are no other players looking for a Tic Tac Toe match.\n\nWould you like to:',
            style: TextStyle(color: AppTheme.textSecondary),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
                _findOpponent(); // Try again
              },
              child: const Text('Try Again'),
            ),
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
                _createRoom(); // Create a room and wait
              },
              child: const Text('Create Room'),
            ),
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
                _createBotRoom(); // Play with server bot
              },
              child: const Text('Play vs Bot'),
            ),
          ],
        );
      },
    );
  }

  @override
  void dispose() {
    _stopMoveTimer();
    if (_gameProvider != null) {
      if (roomId != null) {
        _gameProvider!.leaveRoom();
      }
      _gameProvider!.leaveLobby('tic-tac-toe');
    }
    super.dispose();
  }

  Widget _buildPlayerNames() {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    String playerName = authProvider.user?.username ?? 'You';
    String opponentName = 'Searching...';

    // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
    if (gameProvider.currentRoom != null &&
        gameProvider.currentRoom!.players.length >= 2) {
      final myUserId = authProvider.user?.id;
      final opponent = gameProvider.currentRoom!.players.firstWhere(
        (p) => p.user.id != myUserId,
        orElse: () => gameProvider.currentRoom!.players.first,
      );
      opponentName = opponent.user.username;
    } else if (_isSearchingForOpponent || roomId == null) {
      opponentName = 'Searching...';
    } else if (gameEnded) {
      opponentName = 'Opponent';
    }

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: AppTheme.surfaceColor,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        '$playerName vs $opponentName',
        style: Theme.of(context).textTheme.headlineSmall?.copyWith(
              color: AppTheme.textPrimary,
              fontWeight: FontWeight.bold,
            ),
        textAlign: TextAlign.center,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppTheme.backgroundColor,
      appBar: AppBar(
        title: Row(
          children: [
            Image.asset(
              'assets/images/games/tic-tac-toe.jpg',
              width: 24,
              height: 24,
            ),
            const SizedBox(width: 8),
            const Text('Tic Tac Toe'),
          ],
        ),
        backgroundColor: AppTheme.surfaceColor,
        foregroundColor: AppTheme.textPrimary,
        elevation: 0,
        actions: [
          // Move timer in top right corner
          if (_showMoveTimer) ...[
            Container(
              margin: const EdgeInsets.only(right: 16),
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: BoxDecoration(
                color: _moveTimeRemaining <= 10
                    ? Colors.red
                    : AppTheme.primaryColor,
                borderRadius: BorderRadius.circular(16),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.timer,
                    color: Colors.white,
                    size: 16,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    '${_moveTimeRemaining}s',
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ],
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            children: [
              // Show error message if any
              if (_errorMessage != null) ...[
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(16),
                  margin: const EdgeInsets.only(bottom: 20),
                  decoration: BoxDecoration(
                    color: AppTheme.errorColor,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.error, color: Colors.white),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _errorMessage!,
                          style: const TextStyle(color: Colors.white),
                        ),
                      ),
                      IconButton(
                        onPressed: () {
                          setState(() {
                            _errorMessage = null;
                          });
                        },
                        icon: const Icon(Icons.close, color: Colors.white),
                      ),
                    ],
                  ),
                ),
              ],

              // Player Names
              _buildPlayerNames(),

              const SizedBox(height: 20),

              // Game board
              Expanded(
                child: Center(
                  child: AspectRatio(
                    aspectRatio: 1,
                    child: Container(
                      decoration: BoxDecoration(
                        color: AppTheme.surfaceColor,
                        borderRadius: BorderRadius.circular(16),
                      ),
                      padding: const EdgeInsets.all(20),
                      child: GridView.builder(
                        gridDelegate:
                            const SliverGridDelegateWithFixedCrossAxisCount(
                          crossAxisCount: 3,
                          crossAxisSpacing: 8,
                          mainAxisSpacing: 8,
                        ),
                        itemCount: 9,
                        itemBuilder: (context, index) {
                          return GestureDetector(
                            onTap: () => _makeMove(index),
                            child: Container(
                              decoration: BoxDecoration(
                                color: AppTheme.backgroundColor,
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(
                                  color:
                                      AppTheme.textSecondary.withOpacity(0.3),
                                  width: 1,
                                ),
                              ),
                              child: Center(
                                child: Text(
                                  board[index],
                                  style: Theme.of(context)
                                      .textTheme
                                      .displayLarge
                                      ?.copyWith(
                                        color: board[index] == 'X'
                                            ? AppTheme.primaryColor
                                            : AppTheme.accentColor,
                                        fontWeight: FontWeight.bold,
                                      ),
                                ),
                              ),
                            ),
                          );
                        },
                      ),
                    ),
                  ),
                ),
              ),

              const SizedBox(height: 20),

              // Game status (moved below board)
              // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ä–µ–∞–ª—å–Ω–æ –∏—â–µ–º –∏–ª–∏ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è –∏–≥—Ä–∞
              if (_isSearchingForOpponent ||
                  (!gameEnded && !_hasTwoPlayers())) ...[
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(20),
                  decoration: BoxDecoration(
                    color: AppTheme.surfaceColor,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Column(
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          if (_isSearchingForOpponent) ...[
                            SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                color: AppTheme.primaryColor,
                                strokeWidth: 2,
                              ),
                            ),
                            const SizedBox(width: 12),
                          ],
                          Expanded(
                            child: Text(
                              gameStatus,
                              style: Theme.of(context)
                                  .textTheme
                                  .headlineSmall
                                  ?.copyWith(
                                    color: AppTheme.textPrimary,
                                    fontWeight: FontWeight.bold,
                                  ),
                              textAlign: TextAlign.center,
                            ),
                          ),
                        ],
                      ),
                      if (_isSearchingForOpponent &&
                          _searchTimeoutSeconds > 5) ...[
                        const SizedBox(height: 12),
                        Text(
                          'This may take a while if no players are online',
                          style:
                              Theme.of(context).textTheme.bodySmall?.copyWith(
                                    color: AppTheme.textSecondary,
                                  ),
                          textAlign: TextAlign.center,
                        ),
                      ],
                    ],
                  ),
                ),
                const SizedBox(height: 20),
              ],

              // Game end status
              if (gameEnded) ...[
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(20),
                  decoration: BoxDecoration(
                    color: AppTheme.surfaceColor,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Column(
                    children: [
                      Text(
                        gameStatus,
                        style:
                            Theme.of(context).textTheme.headlineSmall?.copyWith(
                                  color: AppTheme.textPrimary,
                                  fontWeight: FontWeight.bold,
                                ),
                        textAlign: TextAlign.center,
                      ),
                      if (winner != null && gameStatus.contains('win')) ...[
                        const SizedBox(height: 8),
                        Text(
                          'Congratulations!',
                          style:
                              Theme.of(context).textTheme.bodyLarge?.copyWith(
                                    color: AppTheme.accentColor,
                                    fontWeight: FontWeight.w600,
                                  ),
                        ),
                      ],
                    ],
                  ),
                ),
                const SizedBox(height: 20),
              ],

              // –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ª–æ–≥–∏–∫–∞ –∫–Ω–æ–ø–æ–∫ —Å —É—á–µ—Ç–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∏–≥—Ä–æ–∫–æ–≤
              if (_shouldShowCancelButton()) ...[
                // –ü–æ–∏—Å–∫ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –ò –º–æ–∂–µ–º –æ—Ç–º–µ–Ω–∏—Ç—å - –∫—Ä–∞—Å–Ω–∞—è –∫–Ω–æ–ø–∫–∞ –æ—Ç–º–µ–Ω—ã
                SizedBox(
                  width: double.infinity,
                  height: 50,
                  child: ElevatedButton(
                    onPressed: _cancelSearch,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.red,
                      foregroundColor: Colors.white,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(Icons.close, color: Colors.white),
                        const SizedBox(width: 8),
                        const Text(
                          'CANCEL GAME',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ] else if (_shouldShowSurrenderButton()) ...[
                // –ò–≥—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞ —Å –¥–≤—É–º—è –∏–≥—Ä–æ–∫–∞–º–∏ - –∫–Ω–æ–ø–∫–∞ —Å–¥–∞—á–∏
                SizedBox(
                  width: double.infinity,
                  height: 50,
                  child: ElevatedButton(
                    onPressed: _surrender,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.orange,
                      foregroundColor: Colors.white,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(Icons.flag, color: Colors.white),
                        const SizedBox(width: 8),
                        const Text(
                          'SURRENDER',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ] else if (gameEnded) ...[
                // –ò–≥—Ä–∞ –∑–∞–∫–æ–Ω—á–µ–Ω–∞ - –∫–Ω–æ–ø–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ Tic Tac Toe –ª–æ–±–±–∏
                CustomButton(
                  text: 'Back to Lobby',
                  onPressed: _backToLobby,
                  backgroundColor: AppTheme.surfaceColor,
                  textColor: AppTheme.textPrimary,
                  width: double.infinity,
                ),
              ],
              // –£–ë–†–ê–ù–ê –∫–Ω–æ–ø–∫–∞ "FIND OPPONENT" - –ø–æ–∏—Å–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π
            ],
          ),
        ),
      ),
    );
  }

  // –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–Ω–æ–ø–∫—É CANCEL GAME
  bool _shouldShowCancelButton() {
    final isWaiting = _isWaitingForSecondPlayer();

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º CANCEL –µ—Å–ª–∏:
    // 1. –ò–¥–µ—Ç –ø–æ–∏—Å–∫ –ò–õ–ò –æ–∂–∏–¥–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞
    // 2. –ò –º—ã –º–æ–∂–µ–º –æ—Ç–º–µ–Ω–∏—Ç—å –ø–æ–∏—Å–∫ (–Ω–∞—á–∞–ª–∏ —Å–∞–º–∏)
    // 3. –ò –∏–≥—Ä–∞ –Ω–µ –∑–∞–∫–æ–Ω—á–µ–Ω–∞
    return (_isSearchingForOpponent || isWaiting) &&
        _canCancelSearch &&
        !gameEnded;
  }

  // –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–Ω–æ–ø–∫—É SURRENDER
  bool _shouldShowSurrenderButton() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º SURRENDER –µ—Å–ª–∏:
    // 1. –ï—Å—Ç—å roomId (–∫–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞)
    // 2. –ù–ï –∏–¥–µ—Ç –ø–æ–∏—Å–∫
    // 3. –ò–≥—Ä–∞ –ù–ï –∑–∞–∫–æ–Ω—á–µ–Ω–∞
    // 4. –ò –µ—Å—Ç—å –î–í–ê –∏–≥—Ä–æ–∫–∞ –≤ –∫–æ–º–Ω–∞—Ç–µ (–∏–≥—Ä–∞ —Ä–µ–∞–ª—å–Ω–æ –Ω–∞—á–∞–ª–∞—Å—å)
    return roomId != null &&
        !_isSearchingForOpponent &&
        !gameEnded &&
        _hasTwoPlayers();
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∂–¥–µ–º –ª–∏ –º—ã –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞ (–µ—Å—Ç—å –∫–æ–º–Ω–∞—Ç–∞, –Ω–æ —Ç–æ–ª—å–∫–æ 1 –∏–≥—Ä–æ–∫)
  bool _isWaitingForSecondPlayer() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ù–ï —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –∂–¥–µ–º –µ—Å–ª–∏ –∏–≥—Ä–∞ —É–∂–µ –Ω–∞—á–∞–ª–∞—Å—å
    if (gameEnded ||
        (gameProvider.currentRoom?.gameState?.data['board'] as List?)
                ?.any((cell) => cell != null) ==
            true) {
      return false; // –ò–≥—Ä–∞ —É–∂–µ –Ω–∞—á–∞–ª–∞—Å—å –∏–ª–∏ –∑–∞–∫–æ–Ω—á–µ–Ω–∞
    }

    bool isWaiting = roomId != null &&
        gameProvider.currentRoom != null &&
        gameProvider.currentRoom!.players.length < 2;

    // –ö–†–ò–¢–ò–ß–ù–û: –ù–ï –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –ø–æ–∏—Å–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ - —ç—Ç–æ –≤—ã–∑—ã–≤–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã
    // –ï—Å–ª–∏ –Ω—É–∂–µ–Ω –ø–æ–∏—Å–∫ - –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É

    return isWaiting;
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –¥–≤–∞ –∏–≥—Ä–æ–∫–∞ –≤ –∫–æ–º–Ω–∞—Ç–µ
  bool _hasTwoPlayers() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    return gameProvider.currentRoom != null &&
        gameProvider.currentRoom!.players.length >= 2;
  }

  void _cancelSearch() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–∏—Å–∫
    setState(() {
      _isSearchingForOpponent = false;
      _searchTimeoutSeconds = 0;
      gameStatus = 'Search cancelled';
    });

    // –ü–æ–∫–∏–Ω—É—Ç—å —Ç–µ–∫—É—â—É—é –∫–æ–º–Ω–∞—Ç—É –µ—Å–ª–∏ –µ—Å—Ç—å
    if (roomId != null) {
      gameProvider.leaveRoom();
    }

    // –ü–æ–∫–∏–Ω—É—Ç—å –ª–æ–±–±–∏
    gameProvider.leaveLobby('tic-tac-toe');

    // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–∞–π–º–µ—Ä —Ö–æ–¥–∞
    _stopMoveTimer();

    // –°–±—Ä–æ—Å–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    setState(() {
      board = List.filled(9, '');
      currentPlayer = 'X';
      gameStatus = 'Ready to play';
      gameEnded = false;
      winner = null;
      isMyTurn = false;
      mySymbol = null;
      roomId = null;
      _errorMessage = null;
      _showMoveTimer = false;
      _moveTimeRemaining = 0;
    });

    // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –ª–æ–±–±–∏ –∏–≥—Ä—ã –≤–º–µ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—Ç–∞ –Ω–∞ –≥–ª–∞–≤–Ω—É—é
    Navigator.of(context).pushReplacement(
      MaterialPageRoute(
        builder: (context) => GameLobbyScreen(
          gameType: 'tic-tac-toe',
          gameTitle: 'Tic Tac Toe',
        ),
      ),
    );
  }

  void _surrender() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    // –ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          backgroundColor: AppTheme.surfaceColor,
          title: Text(
            'Surrender Game',
            style: TextStyle(color: AppTheme.textPrimary),
          ),
          content: Text(
            'Are you sure you want to surrender? You will lose this game.',
            style: TextStyle(color: AppTheme.textSecondary),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text(
                'Cancel',
                style: TextStyle(color: AppTheme.textSecondary),
              ),
            ),
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
                _confirmSurrender();
              },
              child: Text(
                'Surrender',
                style: TextStyle(color: Colors.red),
              ),
            ),
          ],
        );
      },
    );
  }

  void _confirmSurrender() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∏–≥–Ω–∞–ª —Å–¥–∞—á–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä (–ø–æ–∫–∏–¥–∞–µ–º –∏–≥—Ä—É = —Å–¥–∞—á–∞)
    if (gameProvider.isConnected && roomId != null) {
      gameProvider.leaveRoom(); // –ò—Å–ø–æ–ª—å–∑—É–µ–º leaveRoom –¥–ª—è —Å–¥–∞—á–∏

      setState(() {
        gameStatus = 'You lost (surrendered)'; // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å
        gameEnded = true;
        winner = mySymbol == 'X' ? 'O' : 'X'; // –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –ø–æ–±–µ–∂–¥–∞–µ—Ç –ø—Ä–∏ —Å–¥–∞—á–µ
      });

      // –ü–æ–∫–∞–∑–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('You surrendered - Game lost'),
          backgroundColor: Colors.red, // –ò–°–ü–†–ê–í–õ–ï–ù–û: –∫—Ä–∞—Å–Ω—ã–π —Ü–≤–µ—Ç –¥–ª—è –ø–æ—Ä–∞–∂–µ–Ω–∏—è
          duration: Duration(seconds: 3),
        ),
      );
    }
  }

  void _backToLobby() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    // –ü–æ–∫–∏–Ω—É—Ç—å —Ç–µ–∫—É—â—É—é –∫–æ–º–Ω–∞—Ç—É –µ—Å–ª–∏ –µ—Å—Ç—å
    if (roomId != null) {
      gameProvider.leaveRoom();
    }

    // –ü–æ–∫–∏–Ω—É—Ç—å –ª–æ–±–±–∏
    gameProvider.leaveLobby('tic-tac-toe');

    // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–∞–π–º–µ—Ä —Ö–æ–¥–∞
    _stopMoveTimer();

    // –ü–µ—Ä–µ–π—Ç–∏ –≤ Tic Tac Toe –ª–æ–±–±–∏ (–∑–∞–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–∏–π —ç–∫—Ä–∞–Ω)
    Navigator.of(context).pushReplacement(
      MaterialPageRoute(
        builder: (context) => GameLobbyScreen(
          gameType: 'tic-tac-toe',
          gameTitle: 'Tic Tac Toe',
        ),
      ),
    );
  }
}
